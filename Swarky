#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations
import sys, re, time, shutil, logging
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Dict, Any

# ---- TOML loader (Python 3.11+: tomllib; altrimenti prova 'toml') -----------------
try:
    import tomllib  # Python 3.11+
    def load_toml_bytes(b: bytes) -> Dict[str, Any]:
        return tomllib.loads(b.decode("utf-8"))
except Exception:
    try:
        import toml  # type: ignore
        def load_toml_bytes(b: bytes) -> Dict[str, Any]:
            return toml.loads(b.decode("utf-8"))
    except Exception:
        tomllib = None
        def load_toml_bytes(b: bytes) -> Dict[str, Any]:
            raise RuntimeError(
                "Impossibile leggere config.toml: serve Python 3.11+ (tomllib) oppure il pacchetto 'toml'."
            )

# ---- CONFIG DATACLASS ----------------------------------------------------------------

@dataclass(frozen=True)
class Config:
    DIR_HPLOTTER: Path
    ARCHIVIO_DISEGNI: Path
    ERROR_DIR: Path
    PARI_REV_DIR: Path
    PLM_DIR: Path
    ARCHIVIO_STORICO: Path
    DIR_ISS: Path
    DIR_FIV_LOADING: Path
    DIR_HENGELO: Path
    DIR_KALT: Path
    DIR_KALT_ERRORS: Path
    DIR_TABELLARI: Path
    LOG_DIR: Optional[Path] = None
    LOG_LEVEL: int = logging.INFO

    @staticmethod
    def from_toml(d: Dict[str, Any]) -> "Config":
        p = d.get("paths", {})
        def P(key: str, default: Optional[str]=None) -> Path:
            val = p.get(key, default)
            if val is None:
                raise KeyError(f"Config mancante: paths.{key}")
            return Path(val)
        log_dir = p.get("log_dir")
        return Config(
            DIR_HPLOTTER=P("hplotter"),
            ARCHIVIO_DISEGNI=P("archivio"),
            ERROR_DIR=P("error_dir"),
            PARI_REV_DIR=P("pari_rev"),
            PLM_DIR=P("plm"),
            ARCHIVIO_STORICO=P("storico"),
            DIR_ISS=P("iss"),
            DIR_FIV_LOADING=P("fiv"),
            DIR_HENGELO=P("heng"),
            DIR_KALT=P("kalt"),
            DIR_KALT_ERRORS=P("kalt_err"),
            DIR_TABELLARI=P("tab"),
            LOG_DIR=Path(log_dir) if log_dir else None,
            LOG_LEVEL=logging.INFO,
        )

# ---- REGEX ---------------------------------------------------------------------------

BASE_NAME = re.compile(r"D(\w)(\w)(\d{6})R(\d{2})S(\d{2})(\w)\.tif$", re.IGNORECASE)
ISS_BASENAME = re.compile(r"G(\d{4})(\w{3})(\d{7})ISSR(\d{2})S(\d{2})\.pdf$", re.IGNORECASE)

# ---- LOGGING -------------------------------------------------------------------------

def month_tag() -> str:
    return datetime.now().strftime("%b.%Y")

def setup_logging(cfg: Config, debug: bool=False):
    level = logging.DEBUG if debug else cfg.LOG_LEVEL
    log_dir = cfg.LOG_DIR or cfg.DIR_HPLOTTER
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / f"Swarky_{month_tag()}.log"
    logging.basicConfig(
        level=level,
        format="%(asctime)s %(levelname)s %(message)s",
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler(log_file, encoding="utf-8")
        ]
    )
    logging.debug("Log file: %s", log_file)

# ---- FS UTILS ------------------------------------------------------------------------

def normalize_extensions(folder: Path):
    for p in folder.glob("*"):
        if p.is_file():
            if p.suffix == ".TIF":
                q = p.with_suffix(".tiff"); p.rename(q); q.rename(q.with_suffix(".tif"))
            elif p.suffix.lower() == ".tiff":
                p.rename(p.with_suffix(".tif"))

def process_h_tif(path: Path) -> Optional[Path]:
    n = path.name.lower()
    if n.endswith("h.tif"):
        newp = path.with_name(path.stem[:-1] + ".tif")
        path.rename(newp)
        return newp
    return None

def copy_to(src: Path, dst_dir: Path):
    dst_dir.mkdir(parents=True, exist_ok=True); shutil.copy2(src, dst_dir / src.name)

def move_to(src: Path, dst_dir: Path):
    dst_dir.mkdir(parents=True, exist_ok=True); shutil.move(str(src), str(dst_dir / src.name))

def write_lines(p: Path, lines: List[str]):
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open("a", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")

# ---- MAPPATURE E VALIDAZIONI ---------------------------------------------------------

def map_location(m: re.Match, cfg: Config) -> dict:
    first = m.group(3)[0]
    l2 = m.group(2).upper()
    out = {}
    if l2 == "M" and first not in ("4","5"): out = ("costruttivi","Costruttivi","m","DETAIL","Italian")
    elif l2 == "K": out = ("bozzetti","Bozzetti","k","Customer Drawings","English")
    elif l2 == "F": out = ("fornitori","Fornitori","f","Vendor Supplied Data","English")
    elif l2 == "T": out = ("tenute_meccaniche","T_meccaniche","t","Customer Drawings","English")
    elif l2 in ("E","S"): out = ("sezioni","Sezioni","s","Customer Drawings","English")
    elif l2 == "N": out = ("marcianise","Marcianise","n","DETAIL","Italian")
    elif l2 == "P": out = ("preventivi","Preventivi","p","Customer Drawings","English")
    elif first == "4": out = ("pID_ELETTRICI","Pid_Elettrici","m","Customer Drawings","Italian")
    elif first == "5": out = ("piping","Piping","m","Customer Drawings","Italian")
    else: out = ("unknown","Unknown","m","Customer Drawings","English")
    folder, log_name, subloc, doctype, lang = out
    arch_tif_loc = m.group(1).upper() + subloc
    dir_tif_loc = cfg.ARCHIVIO_DISEGNI / folder / arch_tif_loc
    return dict(folder=folder, log_name=log_name, subloc=subloc, doctype=doctype, lang=lang, arch_tif_loc=arch_tif_loc, dir_tif_loc=dir_tif_loc)

def size_from_letter(ch: str) -> str:
    return dict(A="A4",B="A3",C="A2",D="A1",E="A0").get(ch.upper(),"A4")

def uom_from_letter(ch: str) -> str:
    return dict(N="(Not applicable)",M="Metric",I="Inch",D="Dual").get(ch.upper(),"Metric")

def check_orientation_ok(tif_path: Path) -> bool:
    try:
        from PIL import Image  # opzionale
        with Image.open(tif_path) as im:
            return im.width > im.height
    except Exception:
        return True

# ---- LOG WRITERS ---------------------------------------------------------------------

def log_swarky(cfg: Config, file_name: str, loc: str, process: str, archive_dwg: str = "", hyd: bool=False):
    d = datetime.now()
    line = f"{d.strftime('%d.%b.%Y')} # {d.strftime('%H:%M:%S')} # {file_name}\t# {loc}{' Hyd' if hyd else ''}\t\t# {process}\t# {archive_dwg}"
    write_lines((cfg.LOG_DIR or cfg.DIR_HPLOTTER)/f"Swarky_{d.strftime('%b.%Y')}.log", [line])

def log_error(cfg: Config, file_name: str, err: str, archive_dwg: str = ""):
    d = datetime.now()
    line = f"{d.strftime('%d.%b.%Y')} # {d.strftime('%H:%M:%S')} # {file_name}\t# ERRORE\t\t# {err}\t# {archive_dwg}"
    write_lines((cfg.LOG_DIR or cfg.DIR_HPLOTTER)/f"Swarky_{d.strftime('%b.%Y')}.log", [line])

# ---- EDI -----------------------------------------------------------------------------

def write_edi(cfg: Config, m: re.Match, file_name: str, loc: dict, hyd: bool, out_dir: Path):
    record = f"D{m.group(1)}{m.group(2)}{m.group(3)}"; rev = m.group(4); sheet = m.group(5)
    size = size_from_letter(m.group(1)); uom = uom_from_letter(m.group(6))
    doctype = "Hydraulic" if hyd else loc["doctype"]; lang = loc["lang"]
    edi = out_dir / (Path(file_name).stem + ".DESEDI")
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if edi.exists(): return
    body = [
        "[Database]","ServerName=ORMDB33","ProjectName=FPD Engineering","[DatabaseFields]",
        f"DocumentNo={record}",f"DocumentRev={rev}",f"SheetNumber={sheet}","Description=",
        f"ActualSize={size}","PumpModel=(UNKNOWN)","OEM=Flowserve","PumpSize=","OrderNumber=","SerialNumber=",
        f"Document_Type={doctype}","DrawingClass=COMMERCIAL","DesignCenter=Desio, Italy","OEMSite=Desio, Italy","OEMDrawingNumber=",
        f"UOM={uom}",f"DWGLanguage={lang}","CurrentRevision=Y","EnteredBy=10150286","Notes=","NonEnglishDesc=","SupersededBy=","NumberOfStages=",
        "[DrawingInfo]",f"DocumentNo={record}",f"SheetNumber={sheet}",
        "Document_Type=Detail" if doctype=="DETAIL" else "Document_Type=Customer Drawings",
        f"DocumentRev={rev}",f"FileName={file_name}","FileType=Tiff",f"Currentdate={now}"
    ]
    write_lines(edi, body)

# ---- PIPELINE PRINCIPALE -------------------------------------------------------------

def archive_once(cfg: Config):
    start = time.time()
    normalize_extensions(cfg.DIR_HPLOTTER)
    for p in sorted(cfg.DIR_HPLOTTER.glob("*.tif")):
        hyd = False
        q = process_h_tif(p)
        if q: p, hyd = q, True
        m = BASE_NAME.search(p.name)
        if not m: log_error(cfg, p.name, "Nome File Errato"); move_to(p, cfg.ERROR_DIR); continue
        if m.group(1).upper() not in "ABCDE": log_error(cfg, p.name, "Formato Errato"); move_to(p, cfg.ERROR_DIR); continue
        if m.group(2).upper() not in "MKFTESNP": log_error(cfg, p.name, "Location Errata"); move_to(p, cfg.ERROR_DIR); continue
        if m.group(6).upper() not in "MIDN": log_error(cfg, p.name, "Metrica Errata"); move_to(p, cfg.ERROR_DIR); continue
        if not check_orientation_ok(p): log_error(cfg, p.name, "Immagine Girata"); move_to(p, cfg.ERROR_DIR); continue

        loc = map_location(m, cfg)
        dir_tif_loc = loc["dir_tif_loc"]; tiflog = loc["log_name"]

        if (dir_tif_loc / p.name).exists():
            log_error(cfg, p.name, "Pari Revisione"); move_to(p, cfg.PARI_REV_DIR); continue

        prefix = f"D{m.group(1)}{m.group(2)}{m.group(3)}"
        candidates = list(dir_tif_loc.glob(f"{prefix}*"))
        beckrev = False
        for ex in candidates:
            me = BASE_NAME.search(ex.name)
            if not me: continue
            chk_sht = "Stesso Foglio" if me.group(5)==m.group(5) else "Foglio Diverso"
            if me.group(4) < m.group(4): chk_rev = "Nuova Revisione"
            elif me.group(4) > m.group(4): chk_rev = "Revisione Precedente"
            else: chk_rev = "Pari Revisione"
            chk_met = "Metrica Uguale" if me.group(6)==m.group(6) else "Metrica Diversa"

            if chk_sht == "Stesso Foglio":
                if chk_rev == "Nuova Revisione":
                    move_to(ex, cfg.ARCHIVIO_STORICO)
                    proc = "ATT.Cambio Metrica" if chk_met=="Metrica Diversa" else "Nuova Revisione"
                    log_swarky(cfg, p.name, tiflog, proc, ex.name, hyd)
                elif chk_rev == "Pari Revisione":
                    if chk_met == "Metrica Diversa":
                        log_swarky(cfg, p.name, tiflog, "Metrica Diversa", ex.name, hyd)
                    else:
                        log_error(cfg, p.name, "Pari Revisione", ex.name); move_to(p, cfg.ERROR_DIR); beckrev=True; break
                else:
                    log_error(cfg, p.name, "Revisione Precendente", ex.name); move_to(p, cfg.ERROR_DIR); beckrev=True; break
            else:
                log_swarky(cfg, p.name, tiflog, "Foglio Diverso", ex.name, hyd)
        if beckrev: continue

        copy_to(p, cfg.PLM_DIR)
        move_to(p, dir_tif_loc)
        write_edi(cfg, m, p.name, loc, hyd, cfg.PLM_DIR)

    elapsed = time.time() - start
    write_lines((cfg.LOG_DIR or cfg.DIR_HPLOTTER)/f"Swarky_{datetime.now().strftime('%b.%Y')}.log", [f"ProcessTime # {elapsed:.2f}s"])

def iss_loading(cfg: Config):
    for p in sorted(cfg.DIR_ISS.glob("*.pdf")):
        m = ISS_BASENAME.search(p.name)
        if not m: continue
        move_to(p, cfg.PLM_DIR)
        stem = p.stem
        docno = stem[:18] + stem[24:] if len(stem)>=24 else stem
        now = datetime.now()
        edi = cfg.PLM_DIR/(stem+".DESEDI")
        body = [
            "[Database]","ServerName=ORMDB33","ProjectName=FPD Engineering","[DatabaseFields]",
            f"DocumentNo={docno}",f"DocumentRev={m.group(4)}",f"SheetNumber={m.group(5)}",
            "Description= Impeller Specification Sheet","ActualSize=A4","PumpModel=(UNKNOWN)","OEM=Flowserve",
            "PumpSize=","OrderNumber=","SerialNumber=","Document_Type=DETAIL","DrawingClass=COMMERCIAL",
            "DesignCenter=Desio, Italy","OEMSite=Desio, Italy","OEMDrawingNumber=","UOM=Metric","DWGLanguage=English",
            "CurrentRevision=Y","EnteredBy=10150286","Notes=","NonEnglishDesc=","SupersededBy=","NumberOfStages=",
            "[DrawingInfo]",f"DocumentNo={docno}",f"SheetNumber={m.group(5)}","Document_Type=Detail",
            f"DocumentRev={m.group(5)}",f"FileName={p.name}","FileType=Pdf",f"Currentdate={now.strftime('%Y-%m-%d %H:%M:%S')}"
        ]
        write_lines(edi, body)
        log = cfg.DIR_ISS/"SwarkyISS.log"
        write_lines(log, [f"{now.strftime('%d.%b.%Y')} # {now.strftime('%H:%M:%S')} # {stem}"])

def fiv_loading(cfg: Config):
    for p in sorted(cfg.DIR_FIV_LOADING.glob("*")):
        if not p.is_file(): continue
        _ = process_h_tif(p)
        m = BASE_NAME.search(p.name)
        if not m: continue
        loc = map_location(m, cfg)
        write_edi(cfg, m, p.name, loc, False, cfg.PLM_DIR)
        move_to(p, cfg.PLM_DIR)
        log_swarky(cfg, p.name, loc["log_name"], "Fiv Loading")

def count_tif_files(cfg: Config) -> dict:
    def count(d: Path, pattern: str) -> int:
        try: return len(list(d.glob(pattern)))
        except Exception: return 0
    return {
        "KALT Error": count(cfg.DIR_KALT_ERRORS, "*.err"),
        "Same Rev Dwg": count(cfg.PARI_REV_DIR, "*.tif"),
        "Check Dwg": count(cfg.ERROR_DIR, "*.tif"),
        "Heng Dwg": count(cfg.DIR_HENGELO, "*.tif"),
        "Tab Dwg": count(cfg.DIR_TABELLARI, "*.tif"),
        "Kal Dwg": count(cfg.DIR_KALT, "*.tif"),
    }

def run_once(cfg: Config):
    archive_once(cfg); iss_loading(cfg); fiv_loading(cfg)
    logging.info("Counts: %s", count_tif_files(cfg))

def watch_loop(cfg: Config, interval: int):
    logging.info("Watch ogni %ds...", interval)
    while True:
        run_once(cfg); time.sleep(interval)

# ---- CLI -----------------------------------------------------------------------------

def parse_args(argv: List[str]):
    import argparse
    ap = argparse.ArgumentParser(description="Swarky - batch archiviazione/EDI")
    ap.add_argument("--config", type=str, default="config.toml", help="Percorso file di configurazione TOML")
    ap.add_argument("--watch", type=int, default=0, help="Loop di polling in secondi, 0=esegue una sola passata")
    ap.add_argument("--debug", action="store_true", help="Abilita logging DEBUG")
    return ap.parse_args(argv)

def load_config(path: Path) -> Config:
    if not path.exists():
        raise FileNotFoundError(f"Config non trovato: {path}")
    data = load_toml_bytes(path.read_bytes())
    return Config.from_toml(data)

def main(argv: List[str]):
    args = parse_args(argv)
    cfg_path = Path(args.config)
    cfg = load_config(cfg_path)
    setup_logging(cfg, debug=args.debug)
    if args.watch > 0:
        watch_loop(cfg, args.watch)
    else:
        run_once(cfg)

if __name__ == "__main__":
    try:
        main(sys.argv[1:])
    except KeyboardInterrupt:
        print("Interrotto")
